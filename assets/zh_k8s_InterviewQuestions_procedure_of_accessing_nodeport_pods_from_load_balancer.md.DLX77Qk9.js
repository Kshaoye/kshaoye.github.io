import{_ as e,c as n,o as s,ag as o}from"./chunks/framework.z0p7P-Mv.js";const u=JSON.parse('{"title":"从负载均衡访问K8S nodeport类型的pod的访问流程","description":"","frontmatter":{},"headers":[],"relativePath":"zh/k8s/InterviewQuestions/procedure_of_accessing_nodeport_pods_from_load_balancer.md","filePath":"zh/k8s/InterviewQuestions/procedure_of_accessing_nodeport_pods_from_load_balancer.md"}'),p={name:"zh/k8s/InterviewQuestions/procedure_of_accessing_nodeport_pods_from_load_balancer.md"};function t(l,a,i,r,d,c){return s(),n("div",null,[...a[0]||(a[0]=[o(`<h1 id="从负载均衡访问k8s-nodeport类型的pod的访问流程" tabindex="-1">从负载均衡访问K8S nodeport类型的pod的访问流程 <a class="header-anchor" href="#从负载均衡访问k8s-nodeport类型的pod的访问流程" aria-label="Permalink to &quot;从负载均衡访问K8S nodeport类型的pod的访问流程&quot;">​</a></h1><h2 id="基础知识-关于nodeport类型的pod" tabindex="-1">基础知识：关于NodePort类型的pod <a class="header-anchor" href="#基础知识-关于nodeport类型的pod" aria-label="Permalink to &quot;基础知识：关于NodePort类型的pod&quot;">​</a></h2><p>Kubernetes会在每个节点上分配一个静态端口（范围通常为30000-32767），并将该端口上的流量转发到Service背后的Pod。</p><h2 id="访问流程" tabindex="-1">访问流程 <a class="header-anchor" href="#访问流程" aria-label="Permalink to &quot;访问流程&quot;">​</a></h2><p>负载均衡器将外部流量分发到集群节点的NodePort上，再由kube-proxy转发到Service背后的Pod。</p><p>负载均衡将流量转发到某个Node节点的NodePort，</p><p>Node节点上的kube-proxy通过IPVS或iptables将请求转发到对应 Service，再根据 Service 的后端Endpoints将请求转发到具体 Pod，</p><p>最终由Pod内应用处理请求并返回响应。</p><h2 id="完整访问链路" tabindex="-1">完整访问链路 <a class="header-anchor" href="#完整访问链路" aria-label="Permalink to &quot;完整访问链路&quot;">​</a></h2><p>假设：</p><ul><li>Service 类型：<strong>NodePort</strong></li><li>NodePort：<code>30080</code></li><li>后端 Pod：<code>nginx</code></li></ul><hr><h3 id="_1-客户端-→-负载均衡器load-banlancer-lb" tabindex="-1">① 客户端 → 负载均衡器Load Banlancer（LB） <a class="header-anchor" href="#_1-客户端-→-负载均衡器load-banlancer-lb" aria-label="Permalink to &quot;① 客户端 → 负载均衡器Load Banlancer（LB）&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Client</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>LoadBalancer (SLB / Nginx / F5)</span></span></code></pre></div><ul><li><p>LB 配置后端：</p><ul><li>Node1:30080</li><li>Node2:30080</li><li>Node3:30080</li></ul></li></ul><p>👉 LB <strong>不知道 Pod 的存在</strong>，它只认识 Node。</p><hr><h3 id="_2-负载均衡器-→-某个-node-的-nodeport" tabindex="-1">② 负载均衡器 → 某个 Node 的 NodePort <a class="header-anchor" href="#_2-负载均衡器-→-某个-node-的-nodeport" aria-label="Permalink to &quot;② 负载均衡器 → 某个 Node 的 NodePort&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LB → NodeX:30080</span></span></code></pre></div><ul><li><p>这个 Node：</p><ul><li><strong>可能有 Pod</strong></li><li><strong>也可能没有 Pod</strong></li></ul></li></ul><p>⚠️ 这是 NodePort 的一个关键特性。</p><hr><h3 id="_3-node-上的-kube-proxy-接管流量-关键" tabindex="-1">③ Node 上的 kube-proxy 接管流量（关键） <a class="header-anchor" href="#_3-node-上的-kube-proxy-接管流量-关键" aria-label="Permalink to &quot;③ Node 上的 kube-proxy 接管流量（关键）&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>NodeX:30080</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>kube-proxy</span></span></code></pre></div><p>kube-proxy 做了三件事：</p><ol><li>监听 NodePort</li><li>根据 Service selector 找 Endpoints</li><li>建立转发规则（iptables / IPVS）</li></ol><p>👉 <strong>kube-proxy 是 NodePort 的核心执行者</strong></p><hr><h2 id="_4-kube-proxy-→-service-→-endpoint" tabindex="-1">④ kube-proxy → Service → Endpoint <a class="header-anchor" href="#_4-kube-proxy-→-service-→-endpoint" aria-label="Permalink to &quot;④ kube-proxy → Service → Endpoint&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>NodePort</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>ClusterIP Service</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>Endpoint (Pod IP:Port)</span></span></code></pre></div><ul><li>Service 是 <strong>逻辑对象</strong></li><li>Endpoint 是 <strong>真实 Pod 列表</strong></li></ul><p>kube-proxy 会：</p><ul><li>从 Endpoint 中选一个 Pod</li><li>转发流量过去</li></ul><hr><h2 id="_5-pod-接收请求并响应" tabindex="-1">⑤ Pod 接收请求并响应 <a class="header-anchor" href="#_5-pod-接收请求并响应" aria-label="Permalink to &quot;⑤ Pod 接收请求并响应&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Pod (nginx)</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>Response</span></span>
<span class="line"><span>   ↑</span></span>
<span class="line"><span>原路返回</span></span></code></pre></div><hr><h2 id="一句话总结-可以重点记住这个" tabindex="-1">一句话总结（可以重点记住这个） <a class="header-anchor" href="#一句话总结-可以重点记住这个" aria-label="Permalink to &quot;一句话总结（可以重点记住这个）&quot;">​</a></h2><blockquote><p><strong>外部流量先经负载均衡进入某个Node的NodePort， 再由该Node上的kube-proxy根据Service的Endpoint列表转发到具体Pod。</strong></p></blockquote><hr><h2 id="四、非常关键的-3-个容易被-问死-的点" tabindex="-1">四、非常关键的 3 个容易被“问死”的点 <a class="header-anchor" href="#四、非常关键的-3-个容易被-问死-的点" aria-label="Permalink to &quot;四、非常关键的 3 个容易被“问死”的点&quot;">​</a></h2><h3 id="_1️⃣-node-上没-pod-为什么还能访问" tabindex="-1">1️⃣ Node 上没 Pod，为什么还能访问？ <a class="header-anchor" href="#_1️⃣-node-上没-pod-为什么还能访问" aria-label="Permalink to &quot;1️⃣ Node 上没 Pod，为什么还能访问？&quot;">​</a></h3><p>✅ 因为：</p><ul><li>kube-proxy 在 <strong>所有 Node</strong> 上</li><li>会把流量转发到 <strong>任何 Node 上的 Pod</strong></li></ul><p>👉 NodePort ≠ Pod 直连</p><hr><h3 id="_2️⃣-kube-proxy-用的是什么机制" tabindex="-1">2️⃣ kube-proxy 用的是什么机制？ <a class="header-anchor" href="#_2️⃣-kube-proxy-用的是什么机制" aria-label="Permalink to &quot;2️⃣ kube-proxy 用的是什么机制？&quot;">​</a></h3><ul><li>IPVS（高性能，推荐）</li><li>iptables（之前默认，规则多）</li></ul><p>👉 <strong>两者都是内核转发，不是用户态代理</strong></p><hr><h3 id="_3️⃣-service-endpoint-pod-的关系" tabindex="-1">3️⃣ Service / Endpoint / Pod 的关系 <a class="header-anchor" href="#_3️⃣-service-endpoint-pod-的关系" aria-label="Permalink to &quot;3️⃣ Service / Endpoint / Pod 的关系&quot;">​</a></h3><table tabindex="0"><thead><tr><th>对象</th><th>本质</th></tr></thead><tbody><tr><td>Service</td><td>虚拟 IP + 规则</td></tr><tr><td>Endpoint</td><td>Pod IP 列表</td></tr><tr><td>Pod</td><td>真正处理请求</td></tr></tbody></table><hr><h2 id="加分点-面试能拉开差距" tabindex="-1">加分点（面试能拉开差距） <a class="header-anchor" href="#加分点-面试能拉开差距" aria-label="Permalink to &quot;加分点（面试能拉开差距）&quot;">​</a></h2><p>可以补一句：</p><blockquote><p>“NodePort 的流量路径较长，暴露所有 Node， 在生产环境通常配合外部负载均衡或 Ingress 使用， 而不是直接对公网暴露。”</p></blockquote><hr><h2 id="一个「流程图」-脑海中要有印象" tabindex="-1">一个「流程图」（脑海中要有印象） <a class="header-anchor" href="#一个「流程图」-脑海中要有印象" aria-label="Permalink to &quot;一个「流程图」（脑海中要有印象）&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Client</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>LoadBalancer</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>NodeIP:NodePort</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>kube-proxy</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Service</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Endpoint</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Pod</span></span></code></pre></div><p>只要能把这个顺序说清楚</p><p>这道题就已经能达到80分以上水准。</p><hr><h2 id="关于nodeport的总结" tabindex="-1">关于NodePort的总结 <a class="header-anchor" href="#关于nodeport的总结" aria-label="Permalink to &quot;关于NodePort的总结&quot;">​</a></h2><p>优点：NodePort不依赖额外组件，通过在每个 Node 上暴露端口，使集群外部能够访问Kubernetes服务，NodePort结合kube-proxy可以实现后端Pod的流量转发，适合做测试环境或作为外部负载均衡的接入点。</p><p>缺点：NodePort会拉长流量链路、暴露所有 Node，并增加网络与运维复杂度。</p><p>「加分回答」（可选）</p><p>“在生产环境中通常不会直接暴露 NodePort，而是作为Ingress或外部负载均衡的基础能力。”</p><h2 id="深挖-从ingress或者负载均衡访问nodeport架构是不是更复杂了" tabindex="-1">深挖：从Ingress或者负载均衡访问NodePort架构是不是更复杂了？ <a class="header-anchor" href="#深挖-从ingress或者负载均衡访问nodeport架构是不是更复杂了" aria-label="Permalink to &quot;深挖：从Ingress或者负载均衡访问NodePort架构是不是更复杂了？&quot;">​</a></h2><p>一句话结论：</p><blockquote><p><strong>是更复杂了，但这是“受控复杂度”，而不是“无序复杂度”。</strong></p></blockquote><hr><p>从链路上看，确实多了组件：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Client</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>LB / Ingress</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Service</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Pod</span></span></code></pre></div><p>相比直接 NodePort：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Client</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>NodeIP:NodePort</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Pod</span></span></code></pre></div><p>👉 <strong>组件多了，步骤多了，这是“表象复杂度”。</strong></p><hr><p>但生产环境真正怕的不是“组件多”</p><p>生产环境最怕的是：</p><ul><li>不可控</li><li>不可观测</li><li>不可扩展</li><li>不可隔离</li></ul><p>而 <strong>Ingress / LB 正是在“消灭这些风险”</strong>。</p><p>Ingress / LB 可以把“混乱”集中到“一个地方”。</p><p>NodePort 的复杂度是：</p><ul><li>每个 Node 都暴露端口</li><li>防火墙、ACL、端口冲突难控</li><li>排错要查很多节点</li></ul><p>Ingress / LB 的复杂度是：</p><ul><li><strong>集中在入口层</strong></li><li>后端集群保持干净</li></ul><p>👉 <strong>复杂度被收敛了，而不是扩散了。</strong></p><hr><p>Ingress / LB 带来的能力包括：</p><ul><li>HTTPS 终止</li><li>统一证书管理</li><li>路由规则</li><li>灰度 / 限流 / 鉴权</li><li>访问日志</li></ul><h2 id="这些能力即使没有-ingress-迟早也需要自己去实现" tabindex="-1">这些能力即使没有 Ingress，迟早也需要自己去实现， <a class="header-anchor" href="#这些能力即使没有-ingress-迟早也需要自己去实现" aria-label="Permalink to &quot;这些能力即使没有 Ingress，迟早也需要自己去实现，&quot;">​</a></h2><p>站在运维工程师角度看，短期可能导致学习成本上升， 但是长期收益显著，包括但不限于：</p><ul><li>排错路径清晰</li><li>责任边界明确</li><li>变更影响可控</li></ul><p>👉 <strong>这是典型的“前期复杂，后期省力”。</strong></p><hr><h3 id="补充-一个非常重要的架构区分-必须明确" tabindex="-1">补充：一个非常重要的架构区分（必须明确） <a class="header-anchor" href="#补充-一个非常重要的架构区分-必须明确" aria-label="Permalink to &quot;补充：一个非常重要的架构区分（必须明确）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>类型</th><th>特点</th></tr></thead><tbody><tr><td><strong>必要复杂度</strong></td><td>为了可靠性、扩展性、治理能力</td></tr><tr><td><strong>意外复杂度</strong></td><td>临时方案、补丁、历史包袱</td></tr></tbody></table><p><strong>Ingress / LB 属于前者。</strong> NodePort 滥用往往会制造后者。</p><hr><h3 id="面试时可以直接使用的表述" tabindex="-1">面试时可以直接使用的表述 <a class="header-anchor" href="#面试时可以直接使用的表述" aria-label="Permalink to &quot;面试时可以直接使用的表述&quot;">​</a></h3><blockquote><p>“Ingress 和负载均衡确实引入了额外组件，但它们把访问控制、证书、路由等复杂度集中在入口层，使集群内部保持简单和可治理，这在生产环境是必要的架构取舍。”</p></blockquote><h3 id="一个简单的类比" tabindex="-1">一个简单的类比 <a class="header-anchor" href="#一个简单的类比" aria-label="Permalink to &quot;一个简单的类比&quot;">​</a></h3><ul><li>NodePort： 👉 每个房间都开一扇对外的门</li><li>Ingress / LB： 👉 统一大门 + 门禁 + 前台</li></ul><p><strong>门多不是安全，门少但可控才是。</strong></p>`,104)])])}const b=e(p,[["render",t]]);export{u as __pageData,b as default};
