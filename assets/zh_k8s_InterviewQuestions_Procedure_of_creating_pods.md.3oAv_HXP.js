import{_ as o,c as r,o as p,ag as t}from"./chunks/framework.z0p7P-Mv.js";const u=JSON.parse('{"title":"pod的创建流程","description":"","frontmatter":{},"headers":[],"relativePath":"zh/k8s/InterviewQuestions/Procedure_of_creating_pods.md","filePath":"zh/k8s/InterviewQuestions/Procedure_of_creating_pods.md"}'),a={name:"zh/k8s/InterviewQuestions/Procedure_of_creating_pods.md"};function d(s,e,i,c,n,_){return p(),r("div",null,[...e[0]||(e[0]=[t('<h1 id="pod的创建流程" tabindex="-1">pod的创建流程 <a class="header-anchor" href="#pod的创建流程" aria-label="Permalink to &quot;pod的创建流程&quot;">​</a></h1><p>1:执行 kubectl create -f nginx-deploy yaml → kubectl 向 kube-apiserver 发起创建请求；</p><p>2:kube-apiserver 完成「认证/授权」后，将Deployment 的「期望状态」(比如3个副本）写入etcd，并返回创建成功；</p><p>3:kube-controler-manager 中的 Deployment 控制器，通过apiserver 发现新的 Deployment，自动创建对应的 ReplicaSet;</p><p>4:eplicaSet 控制器发现「期望3个Pod，实际0个」，通过 apiserver 创建3个Pod 的资源对象，写入etcd:</p><p>5:kube-scheduler 监听 apiserver，发现3个[待调度的 Pod」，为每个Pod 筛选并打分，选出最合 适的 Node 节点，将调度结果(Pod 绑定到哪个Node）更新到etcd；</p><p>6:对应 Node节点上的 kubelet，通过apiserver 发现「自己被分配了Pod」，调用容器运行时（Docker/containerd)创建 Pod，Pod 启动成功后，kubelet 将 Pod的「实际运行状态」上报给 apiserver，apiserver 更新到 etcd; pn</p><p>7: kube-proxy 监控到 Pod 创建后，更新本地的 iptables/ipvs 规则，让 Service 可以转发流量到新Pod;</p><p>后续如果某个Pod宕机</p><p>→ ReplicaSet控制器发现「实际2个Pod+期望 3个」</p><p>→自动创建新Pod</p><p>→ scheduler 重新调度</p><p>→ kubelet 创建 Pod，完成自愈。</p>',13)])])}const P=o(a,[["render",d]]);export{u as __pageData,P as default};
