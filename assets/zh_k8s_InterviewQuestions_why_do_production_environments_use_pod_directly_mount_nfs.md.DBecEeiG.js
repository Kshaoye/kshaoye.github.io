import{_ as a,c as l,o as e,ag as s}from"./chunks/framework.z0p7P-Mv.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh/k8s/InterviewQuestions/why_do_production_environments_use_pod_directly_mount_nfs.md","filePath":"zh/k8s/InterviewQuestions/why_do_production_environments_use_pod_directly_mount_nfs.md"}'),t={name:"zh/k8s/InterviewQuestions/why_do_production_environments_use_pod_directly_mount_nfs.md"};function o(n,i,r,p,h,d){return e(),l("div",null,[...i[0]||(i[0]=[s(`<h2 id="一句话结论" tabindex="-1">一句话结论 <a class="header-anchor" href="#一句话结论" aria-label="Permalink to &quot;一句话结论&quot;">​</a></h2><blockquote><p><strong>Pod 不直接挂 NFS，是为了让“存储”从“Pod 生命周期”中解耦出来。</strong></p></blockquote><p>这是面试官最想听到的一句话。</p><hr><h2 id="追问1-如果-pod-直接挂-nfs-会发生什么问题" tabindex="-1">追问1：如果 Pod 直接挂 NFS，会发生什么问题？ <a class="header-anchor" href="#追问1-如果-pod-直接挂-nfs-会发生什么问题" aria-label="Permalink to &quot;追问1：如果 Pod 直接挂 NFS，会发生什么问题？&quot;">​</a></h2><p>假设每个 Pod 在 YAML 里直接写 NFS 地址和路径</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">volumes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">data</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  nfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10.0.0.10</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/data/nginx</span></span></code></pre></div><p>表面看：能用</p><p>实际工程中：问题一堆</p><h3 id="问题1-pod-是-易失的-存储是-长期的-生命周期不匹配" tabindex="-1">问题1：Pod 是“易失的”，存储是“长期的”（生命周期不匹配） <a class="header-anchor" href="#问题1-pod-是-易失的-存储是-长期的-生命周期不匹配" aria-label="Permalink to &quot;问题1：Pod 是“易失的”，存储是“长期的”（生命周期不匹配）&quot;">​</a></h3><ul><li><p>Pod：</p><ul><li>会重建</li><li>会漂移到别的 Node</li><li>会被 Deployment 删除重建</li></ul></li><li><p>NFS 数据：</p><ul><li>应该长期存在</li><li>不应因为 Pod 重建而丢失或混乱</li></ul></li></ul><p>👉 <strong>把 NFS 写死在 Pod 里 = 把长期资源绑在短期对象上</strong></p><hr><h3 id="问题2-管理复杂度爆炸-这是生产级大坑" tabindex="-1">问题2： 管理复杂度爆炸（这是生产级大坑） <a class="header-anchor" href="#问题2-管理复杂度爆炸-这是生产级大坑" aria-label="Permalink to &quot;问题2： 管理复杂度爆炸（这是生产级大坑）&quot;">​</a></h3><p>如果生产环境有：</p><ul><li>100 个 Pod</li><li>每个 Pod YAML 都写一段 NFS</li></ul><p>会遇到的问题：</p><ul><li>NFS 地址改了 → 改 100 个 YAML</li><li>权限问题 → 每个 Pod 单独排查</li><li>路径冲突 → 极容易误挂同一目录</li></ul><p>👉 <strong>没有统一抽象层，无法规模化管理</strong></p><hr><h3 id="问题3-调度器-控制器-看不懂你的存储" tabindex="-1">问题3： 调度器 &amp; 控制器“看不懂你的存储” <a class="header-anchor" href="#问题3-调度器-控制器-看不懂你的存储" aria-label="Permalink to &quot;问题3： 调度器 &amp; 控制器“看不懂你的存储”&quot;">​</a></h3><p>kube-scheduler 调度 Pod 时：</p><ul><li><p><strong>并不知道 NFS 的状态</strong></p></li><li><p>不知道：</p><ul><li>NFS 是否可用</li><li>是否已经被占用</li><li>是否支持多读写</li></ul></li></ul><p>👉 调度 ≠ 存储感知 这在复杂集群里是致命的。</p><hr><h3 id="问题4-权限、安全、隔离全部靠-人记" tabindex="-1">问题4： 权限、安全、隔离全部靠“人记” <a class="header-anchor" href="#问题4-权限、安全、隔离全部靠-人记" aria-label="Permalink to &quot;问题4： 权限、安全、隔离全部靠“人记”&quot;">​</a></h3><ul><li>哪个 Pod 用哪个目录？</li><li>哪个环境能访问哪个 NFS？</li><li>生产 / 测试如何隔离？</li></ul><p>👉 全靠人记 = <strong>不可控风险</strong></p><hr><h2 id="kubernetes-的正确设计-抽象存储" tabindex="-1">Kubernetes 的正确设计：抽象存储 <a class="header-anchor" href="#kubernetes-的正确设计-抽象存储" aria-label="Permalink to &quot;Kubernetes 的正确设计：抽象存储&quot;">​</a></h2><p>K8S 的设计思想是：</p><blockquote><p><strong>Pod 只管“我要存储”，不管“存储怎么来”</strong></p></blockquote><p>于是引入了 3 个对象：</p><hr><h3 id="_1、-pv-persistentvolume-——-管理员视角" tabindex="-1">1、 PV（PersistentVolume）—— 管理员视角 <a class="header-anchor" href="#_1、-pv-persistentvolume-——-管理员视角" aria-label="Permalink to &quot;1、 PV（PersistentVolume）—— 管理员视角&quot;">​</a></h3><ul><li><p>描述一块“真实存在的存储”</p></li><li><p>可以是：</p><ul><li>NFS</li><li>Ceph</li><li>云盘</li></ul></li></ul><p>👉 <strong>代表“集群里有哪些存储资源”</strong></p><hr><h3 id="_2️、-pvc-persistentvolumeclaim-——-使用者视角" tabindex="-1">2️、 PVC（PersistentVolumeClaim）—— 使用者视角 <a class="header-anchor" href="#_2️、-pvc-persistentvolumeclaim-——-使用者视角" aria-label="Permalink to &quot;2️、 PVC（PersistentVolumeClaim）—— 使用者视角&quot;">​</a></h3><ul><li><p>Pod 不关心存储类型</p></li><li><p>只关心：</p><ul><li>要多大</li><li>读写模式</li></ul></li></ul><p>👉 <strong>Pod 只绑定 PVC，而不是存储实现</strong></p><hr><h3 id="_3、-storageclass-——-自动化的关键" tabindex="-1">3、 StorageClass —— 自动化的关键 <a class="header-anchor" href="#_3、-storageclass-——-自动化的关键" aria-label="Permalink to &quot;3、 StorageClass —— 自动化的关键&quot;">​</a></h3><ul><li><p>描述：</p><ul><li>存储如何被创建</li><li>用什么provisioner（制备器）</li></ul></li><li><p>实现：</p><ul><li>动态创建 PV</li></ul></li></ul><h2 id="👉-这是云原生架构中真正-像个云-的地方-这里有个彩蛋-前司某老教授离职之后去了其他高校-说了一句经典评价-像个大学" tabindex="-1">👉 <strong>这是云原生架构中真正“像个云”的地方</strong> （这里有个彩蛋，前司某老教授离职之后去了其他高校，说了一句经典评价：“像个大学”） <a class="header-anchor" href="#👉-这是云原生架构中真正-像个云-的地方-这里有个彩蛋-前司某老教授离职之后去了其他高校-说了一句经典评价-像个大学" aria-label="Permalink to &quot;👉 **这是云原生架构中真正“像个云”的地方**
（这里有个彩蛋，前司某老教授离职之后去了其他高校，说了一句经典评价：“像个大学”）&quot;">​</a></h2><h2 id="一句话解释「为什么不直接挂-nfs」-面试版" tabindex="-1">一句话解释「为什么不直接挂 NFS」（面试版） <a class="header-anchor" href="#一句话解释「为什么不直接挂-nfs」-面试版" aria-label="Permalink to &quot;一句话解释「为什么不直接挂 NFS」（面试版）&quot;">​</a></h2><p>可以这样说：</p><blockquote><p>“Pod 的生命周期是短暂的，而存储是长期资源。 Kubernetes 通过 PV / PVC 把存储从 Pod 中解耦， 这样可以实现统一管理、动态供给、权限隔离和调度解耦， 这是生产环境必须的设计。”</p></blockquote><hr><h2 id="工程师级-的补充-加分项" tabindex="-1">“工程师级”的补充（加分项） <a class="header-anchor" href="#工程师级-的补充-加分项" aria-label="Permalink to &quot;“工程师级”的补充（加分项）&quot;">​</a></h2><blockquote><p><strong>直接在 Pod 里写 NFS，本质是把 Kubernetes 当 Docker 用。</strong></p></blockquote><p>而：</p><ul><li>PV/PVC 是 Kubernetes 的存储 API</li><li>StorageClass 是“存储即服务（Storage as a Service）”</li></ul><hr><h2 id="什么时候-可以-直接挂-nfs-也要知道" tabindex="-1">什么时候“可以”直接挂 NFS？（也要知道） <a class="header-anchor" href="#什么时候-可以-直接挂-nfs-也要知道" aria-label="Permalink to &quot;什么时候“可以”直接挂 NFS？（也要知道）&quot;">​</a></h2><p>⚠️ 不是绝对不能：</p><p><strong>仅限以下情况：</strong></p><ul><li>临时测试</li><li>单 Pod</li><li>非关键数据</li><li>学习实验</li></ul><p>👉 <strong>生产环境基本禁止</strong></p><hr><h2 id="一句话总结" tabindex="-1">一句话总结： <a class="header-anchor" href="#一句话总结" aria-label="Permalink to &quot;一句话总结：&quot;">​</a></h2><p>PV/PVC 可以解决“持久化存储资源的抽象、解耦和生命周期管理问题”， 本质是把存储资源从 Pod 中剥离出来，实现统一管理和按需使用。</p><p>也可以在后面补一句： “这样可以支持静态和动态供给，提升存储的可管理性和可扩展性，更适合生产环境。”</p>`,63)])])}const k=a(t,[["render",o]]);export{c as __pageData,k as default};
